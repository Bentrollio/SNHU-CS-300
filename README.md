# SNHU-CS-300
## My work for SNHU's CS-300 Data Structures and Algorithms

### What was the problem you were solving in the projects for this course?

In programming, objects are representations of real-world data and behaviors that the program and user can interact with. While objects can be randomly inserted into storage, a better solution is to provide some sort of order for easier user access like utilizing an identifier such as a bid, course ID, or title. One should also take into account the solution's runtime, which is the number of instructions and resources a solution utilizes to accomplish its goal independent of hardware paramaeters such as processor speed and memory. The problem I seeked to solve was organizing such plain old data objects quickly and efficiently.

### How did you approach the problem? Consider why data structures are important to understand.

I approached the problem by striving to meet the client's (ABCU) current and future needs. ABCU requested the ability to alphanumerically print a list of courses and prerequisites into a mock schedule for students and advisors to print. In my research, I learned about array and node-based data structures. The vector is an array-type data structure that directly stores objects into a computer's memory address. Accessing an element is quick with a constant runtime of O(1). However, insertion and deletion, involves shifting all elements to accomodate the new element (unless appended to the end of the vector). Searching may involve traversing the entire vector in the worst case scenario. This may not be an issue with an 8 course data set, but can cause efficiency problems if ABCU were to implement this program for all degree programs they offer. 
A hash table is one of the fastest node-based data structures. This solution, while quick at search, insertion and deletion (O(1) to O(n) depending on the hash function) inserts objects based on the bucket the hash function returns. These elements are unsorted, and, while the data set is small, there is no guarantee of creating an alphanumerically sorted list.
Finally, a binary search tree provides quick insertion, deletion and search with a balanced search tree providing an average runtime of O(log n) when balanced, but a worst case linear runtime of O(n), like an array-based data structure, when completely unbalanced. The reason I utilized a BST in ABCU's solution was to allow them some futureproofing should they need to insert more classes or delete them. In my opinion, the greatest advantage to utilizing this solution is its efficiency in providing an alphanumerically sorted list when using the in-order traversal algorithm. Data structures are important to understand because they provide an efficient way to organize, maintain and store data while catering to the system's available resources. They also allow one to solve common problems, in this case, alphanumerically sorting strings. Choosing the correct data structure allows one to create high-performing, efficient programs.

### How did you overcome any roadblocks you encountered while going through the activites or project?
I encountered several roadblocks during the assignments in this course. However, I did not let them discourage me. An invaluable resource was **A Common-Sense Guide to Data Structures and Algorithms** by Jay Wengrow. This book allowed me to really wrap my head around the concepts, even though the examples were written in Python, Ruby and Javascript. I also utilized GeeksforGeeks to see several C++ examples of each data structure, and SNHU Professor Watson's videos from the module resources helped tremendously in implementing the code. For me, the toughest part of Project Two was parsing through the text file and tokenizing each word while error-checking that each line was in proper format. It did not help that I created my own implementation of the CSVparser because I both wanted the challenge and to build one from scratch to solidify my understanding of input and output file streams in C++. I really hope that my implementation is not too inefficient.

### How has your work on this project expanded your approach to designing software and developing programs?
This project made me understand the importance of accounting for runtime and cost analysis for each algorithm and data structure implemented in my programs. By heeding these parameters, one can create programs that run on all sorts of hardware, from potatoes to powerhouses.

### How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
This project solidifed the importance of commenting as you go. My text parsing algorithm and BST structure were complex and it is easy to get lost in the weeds without comments. Furthermore, it illustrated the importance of functionalizing different behaviors instead of creating "spaghetti code" that is difficult to troubleshoot. Functionalizing also allowed me to go from looking at the big picture to breaking down the problem into smaller bits. Creatively, I really enjoyed being given a blank canvas to design on instead of working with a template.
